x = [0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1]

def decode(bits):                                                  # Раскодируем полученное сообщение
    H = [
            [1, 0, 0, 0, 0, 1, 1, 1],
            [0, 1, 0, 0, 1, 0, 1, 1],
            [0, 0, 1, 0, 1, 1, 0, 1],
            [0, 0, 0, 1, 1, 1, 1, 0]
        ]
                                                                    # в какой позиции кода ошибка
    locator = [
            [1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1],
            [0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0]
        ]

    decoded = []

    n = len(bits)
    q = n // 8                                                       # будем считать, что количество битов делится нацело на 8, т.к при кодировании получается именно так

    # исправление ошибки
    for i in range(q):
                                                                      # срез: очередные 8 битов входного списка
        c_bits = bits[8 * i : 8 * (i + 1)]
        syndrome = 4 * [0]
        for i in range(4):
            for j in range(8):
                syndrome[i] += H[i][j] * c_bits[j]
            syndrome[i] %= 2
        try:
            k = locator.index(syndrome)
            c_bits[k] = (c_bits[k] + 1) % 2
        except:
            pass

        decoded.extend(c_bits[4:])

    return decoded

y = [1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 
     0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 
     1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 
     1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]
z = decode(y)
print('Расшифрованное сообщение:', z, z == x)