'''
Два студента-программиста решили создать небольшую онлайн-игру. Но, как и любое другое сетевое приложение, игра предполагает передачу игровых данных между сервером и клиентом. Для этого студенты спроектировали пакетный протокол. Чтобы времени хватило на учёбу и придумывание вселенной, ребята поручили его реализацию вам.

Чтобы упростить эту задачу, данные пакета представлены в виде цепочки целых чисел. Каждое число имеет свой интервал допустимых значений, все они прописаны в спецификации. Помимо этого, разработчики предполагают проверку целостности пакета исходя из того, что при передаче есть вероятность искажения одного бита в пакете, и в случае этого искажения пакет должен быть отброшен.

Так как речь идёт об игре в реальном времени, важна скорость передачи пакета, которая зависит в том числе от его размера. Следовательно, он должен быть минимально возможным (т.е. иметь минимальную длину в байтах). Но главное — чтобы работало.

Итак, ваша задача: написать две функции. Первая функция – pack, которая оборачивает данные в пакет согласно спецификации. Данные представлены списком v  произвольной длины, а спецификация — двумя списками: в l хранятся нижние границы соответствующих чисел-полей, r – верхние. Все три списка содержат целые числа, длины списков равны. Гарантируется, что числа в данных принадлежат диапазонам, указанным в спецификации.

Вторая функция – unpack, которая должна декодировать пакет. В функцию передаётся пакет и спецификация. Учтите, что при передаче в пакете может быть одиночное искажение бита, которое ваша функция unpack должна определить и в соответствующем случае вернуть пустую цепочку как признак искажения.
'''

def pack(v, l, r):
    bits = []
    bitwise_sum = False
    
    n = len(v)

    for i in range(n):
        z = r[i] - l[i] + 1
        total_bits = 0
        q = 1
        while z > q:
            q *= 2
            total_bits += 1

        bits_local = []

        x = v[i] - l[i]
        while x > 0:
            bit = x % 2
            bits_local.append(bit)
            if bit == 1:
                bitwise_sum = not bitwise_sum
            total_bits -= 1
            x = x // 2

        for i in range(total_bits):
            bits_local.append(0)

        bits.extend(bits_local[::-1])

    bits.append(int(bitwise_sum))

    r = (8 - len(bits) % 8) % 8
    bits.extend(r * [0])

    output = []
    for i in range(0, len(bits), 8):
        y = 128 * bits[i] + 64 * bits[i + 1] + 32 * bits[i + 2] + 16 * bits[i + 3] + \
            8 * bits[i + 4] + 4 * bits[i + 5] + 2 * bits[i + 6] + 1 * bits[i + 7]
        output.append(y)

    return bytes(output)


def unpack(s, l, r):
    bits = []
    bitwise_sum = False

    for x in s:
        bits_local = []
        k = 0
        while x > 0:
            bit = x % 2
            k += 1
            bits_local.append(bit)
            if bit == 1:
                bitwise_sum = not bitwise_sum
            x = x // 2
        bits_local.extend((8 - k) * [0])
        bits.extend(bits_local[::-1])

    if bitwise_sum:
        return []

    output = []
    n = len(l)
    j = 0

    for i in range(n):
        z = r[i] - l[i] + 1
        total_bits = 0
        q = 1
        while z > q:
            q *= 2
            total_bits += 1

        y = 0
        q = 1
        for k in range(j + total_bits - 1, j - 1, -1):
            y += bits[k] * q
            q *= 2

        output.append(y + l[i])
        j += total_bits

    return output